// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: charts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApp = `-- name: CreateApp :one
INSERT INTO apps (
    chart_id, name, image, app_type, ports, configs, mounts
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, chart_id, name, image, app_type, ports, configs, mounts, created_at
`

type CreateAppParams struct {
	ChartID int32       `json:"chart_id"`
	Name    string      `json:"name"`
	Image   pgtype.Text `json:"image"`
	AppType pgtype.Text `json:"app_type"`
	Ports   pgtype.Text `json:"ports"`
	Configs pgtype.Text `json:"configs"`
	Mounts  pgtype.Text `json:"mounts"`
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) (App, error) {
	row := q.db.QueryRow(ctx, createApp,
		arg.ChartID,
		arg.Name,
		arg.Image,
		arg.AppType,
		arg.Ports,
		arg.Configs,
		arg.Mounts,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.ChartID,
		&i.Name,
		&i.Image,
		&i.AppType,
		&i.Ports,
		&i.Configs,
		&i.Mounts,
		&i.CreatedAt,
	)
	return i, err
}

const createChart = `-- name: CreateChart :one
INSERT INTO charts (
    name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at
`

type CreateChartParams struct {
	Name        string      `json:"name"`
	Version     string      `json:"version"`
	Description pgtype.Text `json:"description"`
	Type        string      `json:"type"`
	ChartUrl    string      `json:"chart_url"`
	ImageTag    pgtype.Text `json:"image_tag"`
	CanaryTag   pgtype.Text `json:"canary_tag"`
	Manifest    pgtype.Text `json:"manifest"`
	IsLatest    pgtype.Bool `json:"is_latest"`
}

func (q *Queries) CreateChart(ctx context.Context, arg CreateChartParams) (Chart, error) {
	row := q.db.QueryRow(ctx, createChart,
		arg.Name,
		arg.Version,
		arg.Description,
		arg.Type,
		arg.ChartUrl,
		arg.ImageTag,
		arg.CanaryTag,
		arg.Manifest,
		arg.IsLatest,
	)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IngressPaths,
		&i.ContainerImages,
		&i.ServicePorts,
		&i.ManifestParsedAt,
	)
	return i, err
}

const createDependency = `-- name: CreateDependency :one
INSERT INTO dependencies (
    chart_id, dependency_name, dependency_version, repository, condition_field
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, chart_id, dependency_name, dependency_version, repository, condition_field, image_tag, canary_tag, created_at
`

type CreateDependencyParams struct {
	ChartID           int32       `json:"chart_id"`
	DependencyName    string      `json:"dependency_name"`
	DependencyVersion string      `json:"dependency_version"`
	Repository        pgtype.Text `json:"repository"`
	ConditionField    pgtype.Text `json:"condition_field"`
}

func (q *Queries) CreateDependency(ctx context.Context, arg CreateDependencyParams) (Dependency, error) {
	row := q.db.QueryRow(ctx, createDependency,
		arg.ChartID,
		arg.DependencyName,
		arg.DependencyVersion,
		arg.Repository,
		arg.ConditionField,
	)
	var i Dependency
	err := row.Scan(
		&i.ID,
		&i.ChartID,
		&i.DependencyName,
		&i.DependencyVersion,
		&i.Repository,
		&i.ConditionField,
		&i.ImageTag,
		&i.CanaryTag,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChart = `-- name: DeleteChart :exec
DELETE FROM charts WHERE name = $1
`

func (q *Queries) DeleteChart(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteChart, name)
	return err
}

const deleteChartApps = `-- name: DeleteChartApps :exec
DELETE FROM apps WHERE chart_id = $1
`

func (q *Queries) DeleteChartApps(ctx context.Context, chartID int32) error {
	_, err := q.db.Exec(ctx, deleteChartApps, chartID)
	return err
}

const deleteChartDependencies = `-- name: DeleteChartDependencies :exec
DELETE FROM dependencies WHERE chart_id = $1
`

func (q *Queries) DeleteChartDependencies(ctx context.Context, chartID int32) error {
	_, err := q.db.Exec(ctx, deleteChartDependencies, chartID)
	return err
}

const deleteChartVersion = `-- name: DeleteChartVersion :exec
DELETE FROM charts WHERE name = $1 AND version = $2
`

type DeleteChartVersionParams struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (q *Queries) DeleteChartVersion(ctx context.Context, arg DeleteChartVersionParams) error {
	_, err := q.db.Exec(ctx, deleteChartVersion, arg.Name, arg.Version)
	return err
}

const fetchChartDependencies = `-- name: FetchChartDependencies :many
SELECT d.dependency_name, d.dependency_version, d.repository 
FROM dependencies d
JOIN charts c ON d.chart_id = c.id
WHERE c.name = $1 AND c.is_latest = TRUE
`

type FetchChartDependenciesRow struct {
	DependencyName    string      `json:"dependency_name"`
	DependencyVersion string      `json:"dependency_version"`
	Repository        pgtype.Text `json:"repository"`
}

func (q *Queries) FetchChartDependencies(ctx context.Context, name string) ([]FetchChartDependenciesRow, error) {
	rows, err := q.db.Query(ctx, fetchChartDependencies, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChartDependenciesRow
	for rows.Next() {
		var i FetchChartDependenciesRow
		if err := rows.Scan(&i.DependencyName, &i.DependencyVersion, &i.Repository); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChart = `-- name: GetChart :one
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at FROM charts WHERE name = $1 AND is_latest = TRUE LIMIT 1
`

func (q *Queries) GetChart(ctx context.Context, name string) (Chart, error) {
	row := q.db.QueryRow(ctx, getChart, name)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IngressPaths,
		&i.ContainerImages,
		&i.ServicePorts,
		&i.ManifestParsedAt,
	)
	return i, err
}

const getChartApps = `-- name: GetChartApps :many
SELECT id, chart_id, name, image, app_type, ports, configs, mounts, created_at FROM apps WHERE chart_id = $1
`

func (q *Queries) GetChartApps(ctx context.Context, chartID int32) ([]App, error) {
	rows, err := q.db.Query(ctx, getChartApps, chartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.ChartID,
			&i.Name,
			&i.Image,
			&i.AppType,
			&i.Ports,
			&i.Configs,
			&i.Mounts,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartByID = `-- name: GetChartByID :one
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at FROM charts WHERE id = $1 LIMIT 1
`

func (q *Queries) GetChartByID(ctx context.Context, id int32) (Chart, error) {
	row := q.db.QueryRow(ctx, getChartByID, id)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IngressPaths,
		&i.ContainerImages,
		&i.ServicePorts,
		&i.ManifestParsedAt,
	)
	return i, err
}

const getChartDependencies = `-- name: GetChartDependencies :many
SELECT d.id, d.chart_id, d.dependency_name, d.dependency_version, d.repository, d.condition_field, d.image_tag, d.canary_tag, d.created_at, c.name as chart_name FROM dependencies d
JOIN charts c ON d.chart_id = c.id
WHERE d.chart_id = $1
`

type GetChartDependenciesRow struct {
	ID                int32            `json:"id"`
	ChartID           int32            `json:"chart_id"`
	DependencyName    string           `json:"dependency_name"`
	DependencyVersion string           `json:"dependency_version"`
	Repository        pgtype.Text      `json:"repository"`
	ConditionField    pgtype.Text      `json:"condition_field"`
	ImageTag          pgtype.Text      `json:"image_tag"`
	CanaryTag         pgtype.Text      `json:"canary_tag"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	ChartName         string           `json:"chart_name"`
}

func (q *Queries) GetChartDependencies(ctx context.Context, chartID int32) ([]GetChartDependenciesRow, error) {
	rows, err := q.db.Query(ctx, getChartDependencies, chartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartDependenciesRow
	for rows.Next() {
		var i GetChartDependenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChartID,
			&i.DependencyName,
			&i.DependencyVersion,
			&i.Repository,
			&i.ConditionField,
			&i.ImageTag,
			&i.CanaryTag,
			&i.CreatedAt,
			&i.ChartName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartVersion = `-- name: GetChartVersion :one
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at FROM charts WHERE name = $1 AND version = $2 LIMIT 1
`

type GetChartVersionParams struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (q *Queries) GetChartVersion(ctx context.Context, arg GetChartVersionParams) (Chart, error) {
	row := q.db.QueryRow(ctx, getChartVersion, arg.Name, arg.Version)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IngressPaths,
		&i.ContainerImages,
		&i.ServicePorts,
		&i.ManifestParsedAt,
	)
	return i, err
}

const listChartVersions = `-- name: ListChartVersions :many
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at FROM charts WHERE name = $1 ORDER BY created_at DESC
`

func (q *Queries) ListChartVersions(ctx context.Context, name string) ([]Chart, error) {
	rows, err := q.db.Query(ctx, listChartVersions, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chart
	for rows.Next() {
		var i Chart
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Type,
			&i.ChartUrl,
			&i.ImageTag,
			&i.CanaryTag,
			&i.Manifest,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IngressPaths,
			&i.ContainerImages,
			&i.ServicePorts,
			&i.ManifestParsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharts = `-- name: ListCharts :many
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at FROM charts WHERE is_latest = TRUE ORDER BY updated_at DESC
`

func (q *Queries) ListCharts(ctx context.Context) ([]Chart, error) {
	rows, err := q.db.Query(ctx, listCharts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chart
	for rows.Next() {
		var i Chart
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Type,
			&i.ChartUrl,
			&i.ImageTag,
			&i.CanaryTag,
			&i.Manifest,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IngressPaths,
			&i.ContainerImages,
			&i.ServicePorts,
			&i.ManifestParsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCharts = `-- name: SearchCharts :many
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at FROM charts 
WHERE name LIKE $1 OR description LIKE $2
ORDER BY updated_at DESC
`

type SearchChartsParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) SearchCharts(ctx context.Context, arg SearchChartsParams) ([]Chart, error) {
	rows, err := q.db.Query(ctx, searchCharts, arg.Name, arg.Description)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chart
	for rows.Next() {
		var i Chart
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Type,
			&i.ChartUrl,
			&i.ImageTag,
			&i.CanaryTag,
			&i.Manifest,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IngressPaths,
			&i.ContainerImages,
			&i.ServicePorts,
			&i.ManifestParsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setLatestVersion = `-- name: SetLatestVersion :exec
UPDATE charts SET is_latest = FALSE WHERE name = $1
`

func (q *Queries) SetLatestVersion(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, setLatestVersion, name)
	return err
}

const setVersionAsLatest = `-- name: SetVersionAsLatest :exec
UPDATE charts SET is_latest = TRUE WHERE name = $1 AND version = $2
`

type SetVersionAsLatestParams struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (q *Queries) SetVersionAsLatest(ctx context.Context, arg SetVersionAsLatestParams) error {
	_, err := q.db.Exec(ctx, setVersionAsLatest, arg.Name, arg.Version)
	return err
}

const updateChart = `-- name: UpdateChart :one
UPDATE charts 
SET version = $1, description = $2, type = $3, chart_url = $4, 
    image_tag = $5, canary_tag = $6, manifest = $7, updated_at = CURRENT_TIMESTAMP
WHERE name = $8 AND version = $9
RETURNING id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at, ingress_paths, container_images, service_ports, manifest_parsed_at
`

type UpdateChartParams struct {
	Version     string      `json:"version"`
	Description pgtype.Text `json:"description"`
	Type        string      `json:"type"`
	ChartUrl    string      `json:"chart_url"`
	ImageTag    pgtype.Text `json:"image_tag"`
	CanaryTag   pgtype.Text `json:"canary_tag"`
	Manifest    pgtype.Text `json:"manifest"`
	Name        string      `json:"name"`
	Version_2   string      `json:"version_2"`
}

func (q *Queries) UpdateChart(ctx context.Context, arg UpdateChartParams) (Chart, error) {
	row := q.db.QueryRow(ctx, updateChart,
		arg.Version,
		arg.Description,
		arg.Type,
		arg.ChartUrl,
		arg.ImageTag,
		arg.CanaryTag,
		arg.Manifest,
		arg.Name,
		arg.Version_2,
	)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IngressPaths,
		&i.ContainerImages,
		&i.ServicePorts,
		&i.ManifestParsedAt,
	)
	return i, err
}
