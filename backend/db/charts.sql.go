// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: charts.sql

package db

import (
	"context"
	"database/sql"
)

const createApp = `-- name: CreateApp :one
INSERT INTO apps (
    chart_id, name, image, app_type, ports, configs, mounts
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
) RETURNING id, chart_id, name, image, app_type, ports, configs, mounts, created_at
`

type CreateAppParams struct {
	ChartID int64          `json:"chart_id"`
	Name    string         `json:"name"`
	Image   sql.NullString `json:"image"`
	AppType sql.NullString `json:"app_type"`
	Ports   sql.NullString `json:"ports"`
	Configs sql.NullString `json:"configs"`
	Mounts  sql.NullString `json:"mounts"`
}

func (q *Queries) CreateApp(ctx context.Context, arg CreateAppParams) (App, error) {
	row := q.db.QueryRowContext(ctx, createApp,
		arg.ChartID,
		arg.Name,
		arg.Image,
		arg.AppType,
		arg.Ports,
		arg.Configs,
		arg.Mounts,
	)
	var i App
	err := row.Scan(
		&i.ID,
		&i.ChartID,
		&i.Name,
		&i.Image,
		&i.AppType,
		&i.Ports,
		&i.Configs,
		&i.Mounts,
		&i.CreatedAt,
	)
	return i, err
}

const createChart = `-- name: CreateChart :one
INSERT INTO charts (
    name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
) RETURNING id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at
`

type CreateChartParams struct {
	Name        string         `json:"name"`
	Version     string         `json:"version"`
	Description sql.NullString `json:"description"`
	Type        string         `json:"type"`
	ChartUrl    string         `json:"chart_url"`
	ImageTag    sql.NullString `json:"image_tag"`
	CanaryTag   sql.NullString `json:"canary_tag"`
	Manifest    sql.NullString `json:"manifest"`
	IsLatest    sql.NullBool   `json:"is_latest"`
}

func (q *Queries) CreateChart(ctx context.Context, arg CreateChartParams) (Chart, error) {
	row := q.db.QueryRowContext(ctx, createChart,
		arg.Name,
		arg.Version,
		arg.Description,
		arg.Type,
		arg.ChartUrl,
		arg.ImageTag,
		arg.CanaryTag,
		arg.Manifest,
		arg.IsLatest,
	)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDependency = `-- name: CreateDependency :one
INSERT INTO dependencies (
    chart_id, dependency_name, dependency_version, repository, condition_field
) VALUES (
    ?, ?, ?, ?, ?
) RETURNING id, chart_id, dependency_name, dependency_version, repository, condition_field, created_at
`

type CreateDependencyParams struct {
	ChartID           int64          `json:"chart_id"`
	DependencyName    string         `json:"dependency_name"`
	DependencyVersion string         `json:"dependency_version"`
	Repository        sql.NullString `json:"repository"`
	ConditionField    sql.NullString `json:"condition_field"`
}

func (q *Queries) CreateDependency(ctx context.Context, arg CreateDependencyParams) (Dependency, error) {
	row := q.db.QueryRowContext(ctx, createDependency,
		arg.ChartID,
		arg.DependencyName,
		arg.DependencyVersion,
		arg.Repository,
		arg.ConditionField,
	)
	var i Dependency
	err := row.Scan(
		&i.ID,
		&i.ChartID,
		&i.DependencyName,
		&i.DependencyVersion,
		&i.Repository,
		&i.ConditionField,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChart = `-- name: DeleteChart :exec
DELETE FROM charts WHERE name = ?
`

func (q *Queries) DeleteChart(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteChart, name)
	return err
}

const deleteChartApps = `-- name: DeleteChartApps :exec
DELETE FROM apps WHERE chart_id = ?
`

func (q *Queries) DeleteChartApps(ctx context.Context, chartID int64) error {
	_, err := q.db.ExecContext(ctx, deleteChartApps, chartID)
	return err
}

const deleteChartDependencies = `-- name: DeleteChartDependencies :exec
DELETE FROM dependencies WHERE chart_id = ?
`

func (q *Queries) DeleteChartDependencies(ctx context.Context, chartID int64) error {
	_, err := q.db.ExecContext(ctx, deleteChartDependencies, chartID)
	return err
}

const deleteChartVersion = `-- name: DeleteChartVersion :exec
DELETE FROM charts WHERE name = ? AND version = ?
`

type DeleteChartVersionParams struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (q *Queries) DeleteChartVersion(ctx context.Context, arg DeleteChartVersionParams) error {
	_, err := q.db.ExecContext(ctx, deleteChartVersion, arg.Name, arg.Version)
	return err
}

const fetchChartDependencies = `-- name: FetchChartDependencies :many
SELECT d.dependency_name, d.dependency_version, d.repository 
FROM dependencies d
JOIN charts c ON d.chart_id = c.id
WHERE c.name = ? AND c.is_latest = TRUE
`

type FetchChartDependenciesRow struct {
	DependencyName    string         `json:"dependency_name"`
	DependencyVersion string         `json:"dependency_version"`
	Repository        sql.NullString `json:"repository"`
}

func (q *Queries) FetchChartDependencies(ctx context.Context, name string) ([]FetchChartDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChartDependencies, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchChartDependenciesRow
	for rows.Next() {
		var i FetchChartDependenciesRow
		if err := rows.Scan(&i.DependencyName, &i.DependencyVersion, &i.Repository); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChart = `-- name: GetChart :one
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at FROM charts WHERE name = ? AND is_latest = TRUE LIMIT 1
`

func (q *Queries) GetChart(ctx context.Context, name string) (Chart, error) {
	row := q.db.QueryRowContext(ctx, getChart, name)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChartApps = `-- name: GetChartApps :many
SELECT id, chart_id, name, image, app_type, ports, configs, mounts, created_at FROM apps WHERE chart_id = ?
`

func (q *Queries) GetChartApps(ctx context.Context, chartID int64) ([]App, error) {
	rows, err := q.db.QueryContext(ctx, getChartApps, chartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []App
	for rows.Next() {
		var i App
		if err := rows.Scan(
			&i.ID,
			&i.ChartID,
			&i.Name,
			&i.Image,
			&i.AppType,
			&i.Ports,
			&i.Configs,
			&i.Mounts,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartByID = `-- name: GetChartByID :one
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at FROM charts WHERE id = ? LIMIT 1
`

func (q *Queries) GetChartByID(ctx context.Context, id int64) (Chart, error) {
	row := q.db.QueryRowContext(ctx, getChartByID, id)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChartDependencies = `-- name: GetChartDependencies :many
SELECT d.id, d.chart_id, d.dependency_name, d.dependency_version, d.repository, d.condition_field, d.created_at, c.name as chart_name FROM dependencies d
JOIN charts c ON d.chart_id = c.id
WHERE d.chart_id = ?
`

type GetChartDependenciesRow struct {
	ID                int64          `json:"id"`
	ChartID           int64          `json:"chart_id"`
	DependencyName    string         `json:"dependency_name"`
	DependencyVersion string         `json:"dependency_version"`
	Repository        sql.NullString `json:"repository"`
	ConditionField    sql.NullString `json:"condition_field"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	ChartName         string         `json:"chart_name"`
}

func (q *Queries) GetChartDependencies(ctx context.Context, chartID int64) ([]GetChartDependenciesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChartDependencies, chartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartDependenciesRow
	for rows.Next() {
		var i GetChartDependenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChartID,
			&i.DependencyName,
			&i.DependencyVersion,
			&i.Repository,
			&i.ConditionField,
			&i.CreatedAt,
			&i.ChartName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartVersion = `-- name: GetChartVersion :one
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at FROM charts WHERE name = ? AND version = ? LIMIT 1
`

type GetChartVersionParams struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (q *Queries) GetChartVersion(ctx context.Context, arg GetChartVersionParams) (Chart, error) {
	row := q.db.QueryRowContext(ctx, getChartVersion, arg.Name, arg.Version)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listChartVersions = `-- name: ListChartVersions :many
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at FROM charts WHERE name = ? ORDER BY created_at DESC
`

func (q *Queries) ListChartVersions(ctx context.Context, name string) ([]Chart, error) {
	rows, err := q.db.QueryContext(ctx, listChartVersions, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chart
	for rows.Next() {
		var i Chart
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Type,
			&i.ChartUrl,
			&i.ImageTag,
			&i.CanaryTag,
			&i.Manifest,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharts = `-- name: ListCharts :many
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at FROM charts WHERE is_latest = TRUE ORDER BY updated_at DESC
`

func (q *Queries) ListCharts(ctx context.Context) ([]Chart, error) {
	rows, err := q.db.QueryContext(ctx, listCharts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chart
	for rows.Next() {
		var i Chart
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Type,
			&i.ChartUrl,
			&i.ImageTag,
			&i.CanaryTag,
			&i.Manifest,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCharts = `-- name: SearchCharts :many
SELECT id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at FROM charts 
WHERE name LIKE ? OR description LIKE ?
ORDER BY updated_at DESC
`

type SearchChartsParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) SearchCharts(ctx context.Context, arg SearchChartsParams) ([]Chart, error) {
	rows, err := q.db.QueryContext(ctx, searchCharts, arg.Name, arg.Description)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chart
	for rows.Next() {
		var i Chart
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Type,
			&i.ChartUrl,
			&i.ImageTag,
			&i.CanaryTag,
			&i.Manifest,
			&i.IsLatest,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setLatestVersion = `-- name: SetLatestVersion :exec
UPDATE charts SET is_latest = FALSE WHERE name = ?
`

func (q *Queries) SetLatestVersion(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, setLatestVersion, name)
	return err
}

const setVersionAsLatest = `-- name: SetVersionAsLatest :exec
UPDATE charts SET is_latest = TRUE WHERE name = ? AND version = ?
`

type SetVersionAsLatestParams struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (q *Queries) SetVersionAsLatest(ctx context.Context, arg SetVersionAsLatestParams) error {
	_, err := q.db.ExecContext(ctx, setVersionAsLatest, arg.Name, arg.Version)
	return err
}

const updateChart = `-- name: UpdateChart :one
UPDATE charts 
SET version = ?, description = ?, type = ?, chart_url = ?, 
    image_tag = ?, canary_tag = ?, manifest = ?, updated_at = CURRENT_TIMESTAMP
WHERE name = ? AND version = ?
RETURNING id, name, version, description, type, chart_url, image_tag, canary_tag, manifest, is_latest, created_at, updated_at
`

type UpdateChartParams struct {
	Version     string         `json:"version"`
	Description sql.NullString `json:"description"`
	Type        string         `json:"type"`
	ChartUrl    string         `json:"chart_url"`
	ImageTag    sql.NullString `json:"image_tag"`
	CanaryTag   sql.NullString `json:"canary_tag"`
	Manifest    sql.NullString `json:"manifest"`
	Name        string         `json:"name"`
	Version_2   string         `json:"version_2"`
}

func (q *Queries) UpdateChart(ctx context.Context, arg UpdateChartParams) (Chart, error) {
	row := q.db.QueryRowContext(ctx, updateChart,
		arg.Version,
		arg.Description,
		arg.Type,
		arg.ChartUrl,
		arg.ImageTag,
		arg.CanaryTag,
		arg.Manifest,
		arg.Name,
		arg.Version_2,
	)
	var i Chart
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Type,
		&i.ChartUrl,
		&i.ImageTag,
		&i.CanaryTag,
		&i.Manifest,
		&i.IsLatest,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
